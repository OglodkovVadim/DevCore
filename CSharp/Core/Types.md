В этот раз поговорим про такую вещь, как тип данных. Это своего рода абстрактная классификация по принципу: сколько занимает места, какие операции применимы, как отображается и т.д.

---
## Глава 1. Значимый тип (Value type)

Из статьи про [[Memory]] мы знаем, что у нас есть две области памяти: стек и куча. Данные, в зависимости от их типа, могут лежать в одной из них. Value-type переменные лежат на стеке и хранят данные внутри себя. 

> Точнее, данные хранятся там, где они были объявлены, например, если это поле класса, то данные хранятся в куче (внутри объекта этого класса).

Основным значимым типом данных в C# является `struct`, так как все простые типы такие, как `int`, `float`, `double` и т.д. тоже являются `struct System.Int32`, `struct System.Single`, `struct System.Double` соответственно. Мы также можем объявить пользовательские структуры через ключевое слово `struct`. 

У value-type данных есть свои особенности:
- При передаче `struct` в качестве аргумента функции или присваивании создается копия этих данных;
- Ограничение по размеру ~16 байт (если больше, то место выделиться на куче -> падение производительности);

  ---
## Глава 2. Ссылочный тип (Reference type)

В отличие от value-type этот тип хранит данные в куче, но при этом все ссылки на адрес лежат в стеке. При передаче этого объекта в методы передаются не сами данные, а только ссылка на адрес и при работе с ними все изменения остаются в куче. Таким образом мы можем получать и менять одни и те же данные в любом месте программы и объекты в куче будут жить, пока есть хотя бы одна ссылка на них.

Основной reference-type — это `class`.  И в отличие от `struct` он поддерживает **наследование** от других структур. Если мы работаем с большим объемом данных и часто передаем объекты в методы или другие части кода, то нам лучше подойдет класс, чтобы не копировать их каждый раз. В противном случае следует использовать структуру, так как стек работает быстрее кучи.

---
## Глава 3. Ключевые слова ref, in, out

Допустим мы объявили локальную переменную — она, по идее, будет храниться в стеке.

```csharp
public void Foo()
{
	int x = 2; // x -> в стеке
}
```

Но допустим нам надо передать ее в другой метод и там изменить значение, а затем продолжить работать в текущем методе. Оборачивать в класс — это неудобно и дорого, как нам ее тогда передать туда по ссылке? Тут приходят на помощь ключевые слова `ref`, `in`, `out`. 

### Ref

Это ключевое слово позволяет value-type передаваться по ссылке. 

```csharp
public void Foo(ref int x)
{
	x = 6;
}

int x = 2;
Foo(ref x);

Console.WriteLine(x); // x = 6
```

### Out

Данное слово говорит методу, чтобы он положил значение в эту переменную. Затем мы можем передавать туда любую переменную данного типа и наш метод будет класть в него выходные значения.

```csharp
public void Foo(out int x)
{
	x = 6;
}

int x;
Foo(out x); 
//  или
Foo(out int x);	

Console.WriteLine(x); // x = 6
```

### In

Позволяет передавать value-type значения в метод по ссылке, но запрещает изменять его. Это нужно для того, чтобы передавать большие объекты без лишнего копирования.

```csharp
public struct Data
{
	public double val_1;
	public double val_2;
//	...
	public double val_n;
}

public void Bar(in Data data)
{	
	data.val_1 = 2; // Нельзя - доступ только для чтения
}

Data data = new Data 
{
	val_1 = 1.0, 
	val_2 = 2.0,
//	...
	val_n = 1e9;
};
```

---
## Глава 4. String & иммутабельность 

В C# тип `string` является классом, то есть ссылочным типом данных и соответственно, вести себя должен, как и обычно. Но не все так однозначно.

Рассмотрим пример:
```csharp
string str1 = "123";
string str2 = str1;
```

Есть строка `"123"`, мы хотим ее присвоить в переменную `string str2`, так как это ссылочный тип данных, то мы просто скопируем ссылку на адрес, где лежит `"123"`. Теперь, если мы изменим что-то в `str2`, то в `str1` это также поменяется, не так ли?

```csharp
string str1 = "123";
string str2 = str1;

str2 = "456"
Console.WriteLine(str1); // -> 123
```

Мы видим, что в `str1` ничего не поменялось. Оказывается, что в C# тип данных `string` является **иммутабельным**. Это означает, что мы не можем ее изменить и каждый раз, когда мы меняем что-то в строке, то создается новый объект `string`, а старый потом удаляется сборщиком мусора

---
## Глава 5. Boxing & Unboxing 

В C# есть базовый тип `object`, от которого наследуются все типы. Но он является ссылочным типом, возникает вопрос, что будет если мы захотим положить value-type `int` в `object`? 

```csharp
int x = 2;
object obj = x; // Boxing
```

Произойдет примерно следующее: выделится память на куче, туда скопируется `int` из стека, а в `obj` положится ссылка на этот объект.

Теперь в обратную сторону
```csharp
int y = (int)obj; // Unboxing
```

Сначала проверится действительно ли в `obj` лежит `int`, если нет, то будет `InvalidCastException`. В случае успеха из кучи скопируется значение в стек.

---