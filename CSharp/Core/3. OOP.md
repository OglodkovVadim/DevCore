В этой статье мы разберем причины возникновения ООП и его основные принципы. 

---
## **Глава 1. Необходимость ООП**

Существуют много различных парадигм программирования и каждая из них подходит под определенный язык (также бывают мультипарадигменные языки) и задачу.

Некоторые примеры парадигм:

**Императивная** 
	Вся логика описывается в виде следующих друг за другом инструкций, последовательно изменяющих состояние программы.

**Процедурное**
	Основана на императивной, но с возможностью разбиения кода на небольшие самостоятельные участки кода - процедуры. При этом подходе каждая задача разбивается на шаги и для них описываются процедуры.

**Функциональное**
	В отличие от процедурной парадигмы здесь не хранится состояние программы и не изменяется от шага к шагу. Результаты функций зависят только от входных данных и результатов других функций. Можно сказать, здесь понятие функции совпадает с понятием функции в математике.

Если раньше задачи программирования в основном были низкоуровневые и предполагали  хранение и последовательное изменение состояния вычислительной техники, то с развитием технологий изменились и задачи. 

Постепенно разрастались вычислительные системы, алгоритмы, стала появляться потребность в цифровизации определенных аспектов нашей жизни. Такого рода задачи требовали серьезное проектирования системы.

Стали появляться языки более высокого уровня абстракции, а все заботы реализации легли на трансляторы (компилятор, интерпретатор и тд). Таким образом человеку стало легче проектировать сложные архитектуры.

Таким образом возникла необходимость разработки новой более абстрактной парадигмы программирования. 

---
## **Глава 2. Устройство ООП**

Объектно-ориентированное программирование - подход, при котором, что следует из названия, код представляет из себя описание объектов и взаимодействия между ними. 

Основной единицей этого подхода является ***класс***. Это пользовательский тип данных, содержащий тематически одинаковые ***поля*** и ***методы***. В качестве полей класса могут быть как элементарные типы данных (value types), так и объекты других классов (reference types). По задумке эти поля хранят т.н. состояние объекта, а методы класса позволяют выполнять какую-то логику, присущую этому классу.

> Поля, методы, properites (C#) и тд - все вместе называется ***члены класса***.

Таким образом, мы получаем самостоятельную сущность со своим состоянием (поля) и возможностями (методы). Тем самым делая код понятным и простым в управлении.

Мы поняли какие сущности есть в таком подходе и в чем их смысл, теперь надо разобрать правила, по которым эти сущности взаимодействуют. В ООП есть 4 основных правила (принципа): ***абстракция, инкапсуляция, наследование, полиморфизм***. 

---
## **Глава 3. Инкапсуляция**

Представим, что у нас есть машина. Чтобы завести двигатель, водитель нажимает кнопку Start.

 Под капотом при этом выполняется несколько шагов (включение ЭБУ, подача искры и т. д.), но водитель не имеет прямого доступа к этим шагам, потому что неправильный порядок их выполнения может сломать двигатель.

В программировании такой подход называется **инкапсуляцией** — это механизм, который позволяет объекту контролировать доступ к своим внутренним данным и методам.

Мы ограничиваем доступ с помощью **модификаторов доступа** (`private`, `public`, `protected`), чтобы не дать пользователю вмешаться во внутреннюю работу класса и нарушить логику.

``` csharp
public class Car
{
	private void StartEBU() => Console.WriteLine("Step 1 done!");
	private void StartSpark() => Console.WriteLine("Step 2 done!");
	private void TurnOnPanel() => Console.WriteLine("Step 3 done!");
	private void TurnOnHeadlights() => Console.WriteLine("Step 4 done!");
	private void CheckSystem() => Console.WriteLine("Step 5 done!");
	
	public void Start()
	{
		StartEBU();
		StartSpark(); 
		TurnOnPanel();
		TurnOnHeadlights();
		CheckSystem();
		
		Console.WriteLine("Engine is running successfully!");
	}
}

public class Program
{
	public static void Main(string[] args)
	{
		Car car = new Car();
		car.Start();
	}
}
```

Если бы в классе Car все методы были `public`, то при его использовании мы могли бы, например, в любой момент (например, во время движения) вызвать метод `StartSpark()` и сломать двигатель.

То есть суть инкапсуляции - это ограничить доступ к тем полям и методам, которые могут нарушить состояние объекта при неверном взаимодействии.

---
## **Глава 4. Наследование**

Представьте, что у нас есть следующий класс `Car`

```csharp
public class Car
{
	public string Model { get; set; }
	public string Color { get; set; }
	
	public void StartEndine() => Console.WriteLine("Engine is running");
}
```

Теперь нам надо добавить класс `Truck` (типо эвакуатор), который умеет абсолютно тоже, что и `Car`, но еще он умеет поднимать машины. Зачем нам переписывать одинаковые поля и методы, которые уже описаны в классе Car, мы можем просто взять за основу класс `Car` и расширить его добавив метод `LiftCar().`

```csharp
public class Truck : Car
{
	public void LiftCar() => Console.WriteLine("Car is lifting");
}
```

Таким образом, мы избегаем лишнего дублирования кода. Общий функционал принято выносить в базовый класс, а в классах наследниках реализуются конкретные различия.

---
## **Глава 5. Полиморфизм**

Полиморфизм (от греч. _poly_ — «много», _morphē_ — «форма») означает, что один метод может иметь множество различных форм.

Существует ***статический*** (его еще называют ***ранним связыванием***) и ***динамический*** (***позднее связывание***) полиморфизм.

#### Статический полиморфизм

Все мы видели на C#, например, в Visual Studio, когда мы пишем название метода из какой-либо библиотеки, он высвечивает подсказку с принимаемыми типами данных в нескольких вариантах и называет их ***перегрузка***. Так вот перегрузка - это и есть пример статического полиморфизма. То есть становиться понятно какой вариант функции будет использоваться уже на этапе компиляции.

Главные особенности перегрузки методов:
 - одинаковое название методов
 - различие лишь в сигнатуре (возвращаемый тип, аргументы)
 - минимум одно различие в сигнатуре

```csharp
public class Math
{
	public static int Sum(int a, int b) => a + b;
	public static double Sum(double a, double b) => a + b;
	public static int Sum(int a, int b, int c) => a + b + c;
}
```


#### Динамический полиморфизм

Если при статическом полиморфизме конкретная реализация метода определяется на этапе компиляции по ее сигнатуре, то при динамическом это происходит во время выполнения программы. Когда мы определяем в базовом классе абстрактный или виртуальный метод то в классах наследниках его можно переопределить. 

> ***Абстрактный метод*** - это метод, который объявляется только в абстрактных классах и не имеет своего определения. 
> 
> ***Виртуальный метод*** - это метод, который объявляется в любом классе и имеет свое определение. Это определение, грубо говоря, - значение по умолчанию, которое классы-наследники могут переопределить при желании.

 ***Только эти методы можно переопределять в классах наследниках.***

```csharp
public abstract class Vehicle
{
	public abstract string GetColor();
	public virtual void StartEngine()
	{
		Console.WriteLine("Get inside");
		Console.WriteLine("Put keys in lock");
		Console.WriteLine("Rotate & hold keys")
	}
}

public class Motorcycle : Vehicle
{
	public override string GetColor() => "Red";
	public override void StartEngine()
	{
		Console.WriteLine("Get on a motorcycle");
		Console.WriteLine("Push a kick start lever");
	}
}

public class Truck : Vehicle
{
	public override string GetColor() => "Green";
}

public class SportCar : Vehicle
{
	public override string GetColor() => "Blue";
}
```

---
## **Глава 6. Абстракция**

Принцип абстракции очень похож на принцип инкапсуляции. И тот и тот принцип нужен для удобства работы с классом. В случае инкапсуляции от нас скрывают лишние члены класса, чтобы мы ничего не сломали случайно. А в случае абстракции от нас скрывают детали реализации, которые нам не нужно знать и дают простой интерфейс для пользования.

Допустим у нас есть несколько классов транспорта и все они умеют двигаться и останавливаться по своему.

``` csharp
public class Bike
{
	public void Move() => Console.WriteLine("Bike is moving");
	public void Stop() => Console.WriteLine("Bike stopped");
}

public class Car
{
	public void Move() => Console.WriteLine("Car is moving");
	public void Stop() => Console.WriteLine("Car stopped");
}

public class Truck
{
	public void Move() => Console.WriteLine("Truck is moving");
	public void Stop() => Console.WriteLine("Truck stopped");
}
```

Теперь с такими сущностями мы должны создать программу, которая последовательно запускает гонку с каждым транспортом.

``` csharp
public class Program
{
	public static void BikeRace(Bike bike)
	{
		bike.Move();
		Thread.Sleep(5000);
		bike.Stop();
	}
	
	public static void CarRace(Car car)
	{
		car.Move();
		Thread.Sleep(5000);
		car.Stop();
	}
	
	public static void TruckRace(Truck truck)
	{
		truck.Move();
		Thread.Sleep(5000);
		truck.Stop();
	}
	
	public static void Main(string[] args)
	{
		Bike bike = new Bike();
		Car car = new Car();
		Truck truck = new Truck();
		
		BikeRace(bike);
		CarRace(car);
		TruckRace(truck);
	}
}
```

Теперь представим, что будет если у нас добавятся еще 5 классов транспорта, тогда нам надо будет по мимо описания этих 5 классов, добавить еще 5 одинаковых функций, которые принимают объекты разных классов.

Теперь посмотрим, что дает нам абстракция

``` csharp
public abstract class Vehicle
{
	public abstract void Move();
	public abstract void Stop();
}

public class Bike : Vehicle
{
	public override void Move() => Console.WriteLine("Bike is moving");
	public override void Stop() => Console.WriteLine("Bike stopped");
}

public class Car : Vehicle
{
	public override void Move() => Console.WriteLine("Car is moving");
	public override void Stop() => Console.WriteLine("Car stopped");
}

public class Truck : Vehicle
{
	public override void Move() => Console.WriteLine("Truck is moving");
	public override void Stop() => Console.WriteLine("Truck stopped");
}

public class Program
{
	public static void Race(Vehicle vehicle)
	{
		vehicle.Move();
		Thread.Sleep(5000);
		vehicle.Stop();
	}
	
	public static void Main(string[] args)
	{
		List<Vehicle> vehicles =
		[
			new Bike(),
			new Car(),
			new Truck()
		]
		
		vehicle.ForEach(Race);
	}
}
```

Теперь мы можем не привязываться к конкретным типам, а работать с ними через абстракцию в виде класса `Vehicle`.

---
## **Глава 7. Интерфейсы**

По мимо абстрактных классов есть еще ***интерфейсы***. Это тот же самый абстрактный тип данных, чей экземпляр нельзя создать, но методы его могут быть только абстрактными, причем слово `abstract` не указывается.

```csharp
public interface IPrintable
{
	public void print(string message);
}
```

В C# не поддерживается множественное наследование от базовых классов, но можно имплементировать множество интерфейсов. Связано это с тем, что методы в интерфейсах лежат не в Method Table (как у всех обычных классов и базовых классов), а в interface map, поиск по которому занимает больше времени, чем по первому.

Также интерфейс не может содержать обычные поля, а только свойства (properties) и методы. То есть интерфейс, грубо говоря, определяет, что класс (который его имплементирует) умеет.

---
## **Глава 8. Композиция**

Композиция - это подход, при котором объекты создаются ***из*** других объектов, а не расширяют их. Например, есть у нас объект двигатель (Engine) у него свои поля и свой функционал. Он как бы является самостоятельным объектом. А есть класс машина (Car), которая содержит в себе поле Engine и использует его функционал, когда нужно. 

```csharp 
public class Engine
{
	public string Model { get; set; }
	
	public void Start() => Console.WriteLine("Engine is running");
	public void Stop() => Console.WriteLine("Engine stopped");
}

public class Headlights
{
	public string Color { get; set; }
	
	public void TurnOn() => Console.WriteLine("Headlights on");
	public void TurnOff() => Console.WriteLine("Headlights off");
}

public class Car
{
	public Engine engine = new();
	public Headlights headlights = new();
	
	public void Start()
	{
		engine.Start();
		headlights.TurnOn();
		
		Console.WriteLine("Car is running");
	}
}
```

То есть некий класс может содержать в себе небольшие самостоятельные классы. Таким образом, достигается *слабая связанность* между классами. Классы могут быть заменены другими классами, реализующими тот же интерфейс, что позволяет легко изменять поведение классов, не затрагивая другие части системы.

---
## **Заключение**

**Глава 1.**
- Зачем нужно ООП?
- Какие парадигмы бывают?

**Глава 2.**
- Что является основной единицей ООП?
- В чем суть этой парадигмы?

**Глава 3.**
 - Для чего нужна инкапсуляция?

**Глава 4.**
 - Что такое наследование?
 
**Глава 5.**
 - Какие виды полиморфизма бывают?
 - В чем отличие раннего связывания от позднего?
 - Зачем нужен полиморфизм?

**Глава 6.**
 - Какую проблему решает принцип абстракции?

**Глава 7.**
 - В чем разница абстрактного класса и интерфейса?
 - Что может определяться в интерфейсе?

**Глава 8.**
 - В чем отличие наследования от композиции?
 - Какие плюсы композиции?