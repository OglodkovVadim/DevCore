В этой статье мы разберем философию и практику объектно-ориентированного программирования (ООП).

Мы рассмотрим, как появилась сама идея ООП, почему она стала доминирующей парадигмой в современном программировании и как принципы ООП реализованы в C#.

Также заглянем под капот — как именно объекты устроены на уровне памяти и как CLR управляет ими.

---

## **Глава 1. Необходимость ООП**

Существуют много различных парадигм программирования и каждая из них подходит под определенный язык (также бывают мультипарадигменные языки) и задачу.

Некоторые примеры парадигм:

**Императивная** 
	Вся логика описывается в виде следующих друг за другом инструкций, последовательно изменяющих состояние программы.

**Процедурное**
	Основана на императивной, но с возможностью разбиения кода на небольшие самостоятельные участки кода - процедуры. При этом подходе каждая задача разбивается на шаги и для них описываются процедуры.

**Функциональное**
	В отличие от процедурной парадигмы здесь не хранится состояние программы и не изменяется от шага к шагу. Результаты функций зависят только от входных данных и результатов других функций. Можно сказать, здесь понятие функции совпадает с понятием функции в математике.

Если раньше задачи программирования в основном были низкоуровневые и предполагали изменение хранение и последовательное изменение состояния вычислительной техники, то с развитием технологий изменились и задачи. 

Постепенно разрастались вычислительные системы, алгоритмы, стала появляться потребность в цифровизации определенных аспектов нашей жизни. Такого рода задачи требовали серьезное проектирования системы и для удобства пришлось отделить реализацию и сосредоточится на абстракциях. 

Таким образом возникла необходимость разработки новой более абстрактной парадигмы программирования. 

---
## **Глава 2. Основная идея ООП**

Объектно-ориентированное программирование - подход, при котором, что следует из названия, код представляет из себя описание объектов и взаимодействия между ними. 

Основной единицей этого подхода является ***класс***. Это пользовательский тип данных, содержащий тематически одинаковые ***поля*** и ***методы***. В качестве полей класса могут быть как элементарные типы данных (value types), так и объекты других классов (reference types). По задумке эти поля хранят т.н. состояние объекта, а методы класса позволяют выполнять какую-то логику, присущую этому классу.

> Поля, методы, properites (C#) и тд - все вместе называется ***члены класса***.

Таким образом, мы получаем самостоятельную сущность со своим состоянием (поля) и возможностями (методы). Тем самым делая код понятным и простым в управлении.

Мы поняли какие сущности есть в таком подходе и в чем их смысл, теперь надо разобрать правила, по которым эти сущности взаимодействуют. В ООП есть 4 основных правила (принципа): ***абстракция, инкапсуляция, наследование, полиморфизм***. 

---
## **Глава 3. Абстракция**


---
## **Глава 4. Инкапсуляция**

Представим, что у нас есть машина и нам надо ее завести. Мы садимся в нее и нажимаем на кнопку "Start" и она завелась. То есть пользователю, чтобы завести машину, нужно нажать на кнопку, а машина сама все сделает. 

Предположим, что после нажатия на кнопку "Start" машина делать 5 каких-то шагов в нужном порядке и двигатель запускается.

Пользователю не нужно знать какие шаги делает машина под капотом и в каком порядке, а если он полезет туда вручную запускать, то он может напутать порядок этих шагов или забыть какой-то шаг сделать и сломает двигатель.

Для того, чтобы такого не происходило, в программировании существует инкапсуляция - то есть механизм контроля объектом своего состояния, путем ограничения доступа к своим членам, с помощью *модификаторов доступа public, protected, private*.

``` csharp
public class Car
{
	private void StartEBU() => Console.WriteLine("Step 1 done!");
	private void StartSpark() => Console.WriteLine("Step 2 done!");
	private void TurnOnPanel() => Console.WriteLine("Step 3 done!");
	private void TurnOnHeadlights() => Console.WriteLine("Step 4 done!");
	private void CheckSystem() => Console.WriteLine("Step 5 done!");
	
	public void Start()
	{
		StartEBU();
		StartSpark(); 
		TurnOnPanel();
		TurnOnHeadlights();
		CheckSystem();
		
		Console.WriteLine("Engine is running successfully!");
	}
}

public class Program
{
	public static void Main(string[] args)
	{
		Car car = new Car();
		car.Start();
	}
}
```

На практике, ваш коллега программист разработал какой-нибудь класс для математических вычислений и отдал вам и чтобы вы правильно им воспользовались, он сделал доступным (public) только несколько методов, например CalculateSqrt(), CalculatePow() и тд, а как он их внутри реализовал вас волновать не должно.

---
## **Глава 5. Наследование**


---

## **Глава 6. Полиморфизм**

  
---

## **Глава 7. Композиция против наследования**


---

## **Заключение**


