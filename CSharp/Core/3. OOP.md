В этой статье мы разберем философию и практику объектно-ориентированного программирования (ООП).

Мы рассмотрим, как появилась сама идея ООП, почему она стала доминирующей парадигмой в современном программировании и как принципы ООП реализованы в C#.

Также заглянем под капот — как именно объекты устроены на уровне памяти и как CLR управляет ими.

---

## **Глава 1. Необходимость ООП**

Существуют много различных парадигм программирования и каждая из них подходит под определенный язык (также бывают мультипарадигменные языки) и задачу.

Некоторые примеры парадигм:

**Императивная** 
	Вся логика описывается в виде следующих друг за другом инструкций, последовательно изменяющих состояние программы.

**Процедурное**
	Основана на императивной, но с возможностью разбиения кода на небольшие самостоятельные участки кода - процедуры. При этом подходе каждая задача разбивается на шаги и для них описываются процедуры.

**Функциональное**
	В отличие от процедурной парадигмы здесь не хранится состояние программы и не изменяется от шага к шагу. Результаты функций зависят только от входных данных и результатов других функций. Можно сказать, здесь понятие функции совпадает с понятием функции в математике.

Если раньше задачи программирования в основном были низкоуровневые и предполагали изменение хранение и последовательное изменение состояния вычислительной техники, то с развитием технологий изменились и задачи. 

Постепенно разрастались вычислительные системы, алгоритмы, стала появляться потребность в цифровизации определенных аспектов нашей жизни. Такого рода задачи требовали серьезное проектирования системы и для удобства пришлось отделить реализацию и сосредоточится на абстракциях. 

Таким образом возникла необходимость разработки новой более абстрактной парадигмы программирования. 

---
## **Глава 2. Основная идея ООП**

Объектно-ориентированное программирование - подход, при котором, что следует из названия, код представляет из себя описание объектов и взаимодействия между ними. 

Основной единицей этого подхода является ***класс***. Это пользовательский тип данных, содержащий тематически одинаковые ***поля*** и ***методы***. В качестве полей класса могут быть как элементарные типы данных (value types), так и объекты других классов (reference types). По задумке эти поля хранят т.н. состояние объекта, а методы класса позволяют выполнять какую-то логику, присущую этому классу.

> Поля, методы, properites (C#) и тд - все вместе называется ***члены класса***.

Таким образом, мы получаем самостоятельную сущность со своим состоянием (поля) и возможностями (методы). Тем самым делая код понятным и простым в управлении.

Мы поняли какие сущности есть в таком подходе и в чем их смысл, теперь надо разобрать правила, по которым эти сущности взаимодействуют. В ООП есть 4 основных правила (принципа): ***абстракция, инкапсуляция, наследование, полиморфизм***. 

---
## **Глава 3. Абстракция**



---
## **Глава 4. Инкапсуляция**

Представим, что у нас есть машина. Чтобы завести двигатель, водитель нажимает кнопку Start.

 Под капотом при этом выполняется несколько шагов (включение ЭБУ, подача искры и т. д.), но водитель не имеет прямого доступа к этим шагам, потому что неправильный порядок их выполнения может сломать двигатель.

В программировании такой подход называется **инкапсуляцией** — это механизм, который позволяет объекту контролировать доступ к своим внутренним данным и методам.

Мы ограничиваем доступ с помощью **модификаторов доступа** (private, public, protected), чтобы не дать пользователю вмешаться во внутреннюю работу класса и нарушить логику.

``` csharp
public class Car
{
	private void StartEBU() => Console.WriteLine("Step 1 done!");
	private void StartSpark() => Console.WriteLine("Step 2 done!");
	private void TurnOnPanel() => Console.WriteLine("Step 3 done!");
	private void TurnOnHeadlights() => Console.WriteLine("Step 4 done!");
	private void CheckSystem() => Console.WriteLine("Step 5 done!");
	
	public void Start()
	{
		StartEBU();
		StartSpark(); 
		TurnOnPanel();
		TurnOnHeadlights();
		CheckSystem();
		
		Console.WriteLine("Engine is running successfully!");
	}
}

public class Program
{
	public static void Main(string[] args)
	{
		Car car = new Car();
		car.Start();
	}
}
```

---
## **Глава 5. Наследование**


---

## **Глава 6. Полиморфизм**

  
---

## **Глава 7. Композиция против наследования**


---

## **Заключение**


