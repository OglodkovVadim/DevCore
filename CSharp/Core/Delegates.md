В этой статье речь пойдет про ***делегаты.*** Разберём, что это, зачем это нужно и чем оно является на самом деле.

---
## Глава 1.  Определение

Я не стану писать определение с умными словами, давайте лучше попробуем догадаться через пример в чем суть делегатов.

Допустим, у нас есть функция, которая фильтрует список товаров по какому-нибудь признаку, а также выполняет дополнительную логику, например формирует логи в процессе или обращается к чему-либо. Затем мы используем эту функцию во всем проекте.

Но признак, по которому фильтруется список, поменяли или же в конкретном месте понадобилось использовать другой критерий фильтра. Писать новую функцию с почти одинаковым телом или редактировать текущую, добавляя условные конструкции, не хотелось бы. Здесь как раз и пригодятся делегаты.

```csharp
public class DataManager
{
	public delegate bool Filter(int dataUnit);
	
	public static List<int> Filtered(List<int> lstData, Filter filter)
	{		
		/*
		 * Проверяем lstData на валидность;
		 * Выполняем еще какую-нибудь логику, например, с ui
		 */
			
		for (var i = lstData.Count - 1; i >= 0; i--) 
		{
			if (!filter(i))
			{
				lstData.RemoveAt(i);
			}
		}
		
		/*
		 * Отдаем данные обратно;
		 * Возможно опять что-то делаем с ui
		 */
		 
		 return lstData;
	}
}
```

Вот мы написали функцию, которая принимает в качестве фильтра любую функцию, соответствующую сигнатуре делегата `Filter`. Продемонстрируем работу с этой функцией на примере нескольких фильтров.

```csharp
public class Program
{
	public static bool IsPositive(int data) => data > 0;
	public static bool IsOdd(int data) => (data & 1) == 1;

	public void Print(List<int> lst)
	{
		foreach (var item in lst)
			Console.Write($"{item} ");
	}

	public static void Main(string[] args)
	{
		List<int> lstData = [1, -1, 2, -3, -5, 6, 10, 16];
		
		Print(DataManager.Filtered(lstData, IsPositive));
		// Output: 1 2 6 10 16
		
		Print(DataManager.Filtered(lstData, IsOdd));
		// Output: 1 -1 -3 -5
		
	}
}
```

Таким образом, мы можем дописывать или менять функции фильтрации и передавать их туда не трогая основную функцию.

---
## Глава 2.  Предопределенные делегаты

Сигнатура делегатов может быть любая, но среди всего этого множества есть более распространенные их вариации. Поэтому разработчики внедрили некоторые из них как **встроенные универсальные типы**.

#### Predicate

Например, в предыдущей главе я показал делегат, который принимает значение и возвращает `bool`, такой тип делегата разработчики решили встроить и назвать `Predicate`. 

```csharp
Predicate<int> isOdd = x => (x & 1) == 1;
isOdd(1); // -> True
```

#### Func

Если нам нужна функция, которая принимает любое количество входных параметров и выдает результат, то это соответствует делегату `Func`.

> Последний параметр — **тип возвращаемого значения**

```csharp
Func<int, int, int, int> calcSum = (x, y, z) => x + y + z;
calcSum(1, 2, 3); // -> 6
```

#### Action

А если нужна функция, которая принимает сколь угодно входных параметров и при этом ничего не возвращает, то это называется `Action`.

```csharp
Action<int, int, int> printCoords = (x, y, z) => 
	Console.WriteLine($"(x: {x}, y: {y}, z: {z})");
	
printCoords(1, 2, 3);
// Output: (x: 1, y: 2, z: 3)
```

---
## Глава 3.  События

В C# существует **событийная модель**, благодаря которой классы могут оповещать другие классы о возникновении каких-либо ситуаций. В GUI приложениях события позволяют обрабатывать взаимодействие пользователя с элементами, например, нажатие кнопки, изменение выбора в ComboBox и т.д.

События определяются ключевым словом `event`. Их нельзя вызывать напрямую за пределами класса, в котором они объявлены. Также события позволяют безопасно подписывать и отписывать методы. По факту это просто *синтаксический сахар* над делегатом.

```csharp
public class Button
{
	public event Action? Click;
	
	public void Press()
	{
		Console.WriteLine("Button pressed");
		Click?.Invoke();
	}
}
```

Вот так выглядит класс с объявленым событием. С помощью методы `Invoke()` этот делегат вызывает все подписанные на него методы.

```csharp
public void Log()
{
	Console.WriteLine("Button clicked!");
}

Button button = new();
button.Click += Log;
```

Если будет выполнен метод `Press()` в классе `Button`, то у события `Click` будет вызван метод `Invoke()`, после чего отработает функция `Log()`.

---

## Глава 4.  Мультикаст делегаты

У делегатов также есть механизм "подписки" и "отписки" методов. Что позволяет при вызове делегата также вызывать все подписанные на него методы. Такой делегат, содержащий цепочку методов, называется **мультикаст** (multicast delegate). 

Делегат вызывает подписанные на него методы по порядку, причем если хотя бы один из методов вызывает исключение, то вся цепочка останавливается. 

 В предыдущей главе приведен пример с кнопкой и ее событием `Click`, на который подписан метод `Log()`. Давайте доработаем эту модель и добавим еще один метод, который будет выполнять какую-нибудь логику.

```csharp
public void Log()
{
	Console.WriteLine("Button clicked!");
}

public void Foo()
{
	// Происходит какая-то логика
}

Button button = new();
button.Click += Log;
button.Click += Foo;
```

Таким образом, у нас при нажатии на кнопку выполнится два метода. Такой подход помогает разделять логику обработки нажатия на кнопки между разными модулями.

---
## Глава 5.  Анонимные методы и лямбда-выражения

При работе с делегатами часто приходится определять однострочные методы, которые будут использованы один раз, что не очень удобно и лаконично. Поэтому придумали **анонимные методы** и **лямбда-выражения**.

#### Анонимные методы

Они появились в C# 2.0. Содержат только тело без названия (поэтому анонимные) и не могут существовать сами по себе.

Было
```csharp
public delegate int Operation(int a, int b);

public int Sum(int a, int b)
{
	return a + b;
}

Operation operation = Sum;
```

Стало
```csharp
public delegate int Operation(int a, int b);

Operation operation = delegate (int a, int b)
{
	return a + b;
};
```

#### Лямбда-выражения

На анонимных методах люди не остановились и решили еще сильнее упростить синтаксис. В итоге в C# 3.0 появились лямбда-выражения.

```csharp
public delegate int Operation(int a, int b);

Operation operation = (a, b) => a + b;
```

То есть слово `delegate` больше писать не нужно, а описание сигнатуры упростили тем, что теперь не надо явно указывать типы данных. Если лямбда-функция не принимает никаких параметров, то пустые скобки все равно остаются. В общем виде функция выглядит так: `(параметры) => { тело }`.

#### Замыкание (closure)

Представим следующую ситуацию

```csharp
public Func<int, int> Sum(int a)
{
	return x => x + a;
}

var sum = Sum(5);
Console.WriteLine(sum(10));
```

Казалось, бы обычный метод, который возвращает делегат `Func<int, int>`, ну и какая разница что он возвращает. Функция живет в стеке, соответственно при вызове `Sum(5)` функция отработает и удалится из стека вместе с `int a`. Дальше мы снова вызовем эту функцию и она вернет 10. Не так ли?

Если мы запустим эту программу то удивимся тому, что она выведет 15. Как так вышло? Оказывается, когда мы используем делегат (как `Func<int, int>` в этом примере), то он захватывает в себя все свое **лексическое окружение**. То есть все переменные, которые использует делегат "закрываются" внутри него и живут в нем, несмотря на то, что кадр стека с функцией, в которой были объявлены эти переменные, уже уничтожился. Это называется **замыканием**.

Как это работает со стороны компилятора?

---
## Глава 6.  Под капотом

#### Замыкание

На самом деле, когда компилятор видит лямбду, которая использует внешние переменные, он создаёт вспомогательный класс (closure class), в котором захваченные переменные становятся полями, а сама лямбда превращается в метод.

```csharp 
public class Closure
{
	public int x;
	public int Sum(int a)
	{
		return x + a;
	}
}

public Func<int, int> Sum(int a)
{
	Closure closure = new();
	closure.x = a;
	return closure.Sum;
}
```

Теперь значение переменной a хранится в объекте класса `Closure`, который живет на **куче** и пока на этот делегат есть ссылки, он будет жить.

#### Делегаты

Когда мы создаём делегат, компилятор также создаёт вспомогательный класс, в котором будет лежать:
- ссылка на объект, которому принадлежит метод, подписанный на делегат;
- адрес метода (указатель на адрес в таблице методов);
- список методов, подписанных на делегат (multicast delegate)

>**Ссылка на объект** (`object target`) = `null`, если метод статический. 
>
>**Адрес метода** (`_methodPtr`) = `&MyMethod()`, но если это делегат *мультикаст*, то в этом поле будет лежать `thunk` (фрагмент машинного кода), который вызывает все методы из `_invocationList`.
>
>**Список методов** (`invocationList`) = `null`, если делегат не *мультикаст*,

```csharp
public class Module
{
	public delegate void Log(string message);
	
	public void ConsoleLog(string message) => 
		Console.WriteLine;
		
	public void Foo() 
	{
		Log log = ConsoleLog;
		log(); // или log.Invoke(); - одно и то же
	}
}

Module mod = new();
mod.Foo();
```

Log instance
	`_target = mod`
	`_methodPtr = &ConsoleLog`
	`_invocationList = null`

```csharp
public class Module
{
	public delegate void Log(string message);
	
	public void ConsoleLog(string message) => 
		Console.WriteLine;
		
	public void FileLog(string message) => 
		File.AppendAllLines("log.txt", new[] { message });
		
	public void Foo() 
	{
		Log log = ConsoleLog;
		log += FileLog;
		log();
	}
}

Module mod = new();
mod.Foo();
```

Log instance
	`_target = mod`
	`_methodPtr = thunk` (фрагмент машинного кода, вызывающий все методы из списка)
	`_invocationList = [ConsoleLog, FileLog]`


---

## Заключение

Делегаты — это типобезопасные ссылки на методы, которые позволяют передавать их как параметр и хранить их в переменных.

Вся событийная модель C# работает на делегатах.

С их помощью можно писать гибкий код, благодаря тому, что они обеспечивают позднее связывание. То есть конкретное поведение определяется на этапе выполнения, а не компиляции.

Философия делегатов: **"*вызови этот метод, когда произойдет то-то то-то*"**, где не известно заранее, какой метод будет вызван.