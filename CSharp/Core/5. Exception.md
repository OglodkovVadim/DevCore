
В этой статье мы разберем, что такое исключения в C#, как они работают и как с ними правильно обращаться.

---

## **Глава 1. Что такое исключение?**

При написании программы мы не можем предвидеть абсолютно все. Пользователь может ввести текст вместо числа, необходимый файл может отсутствовать на диске, или сервер, к которому мы обращаемся, может быть недоступен.

Если во время выполнения программы (в **runtime**) происходит такая нештатная или ошибочная ситуация, которую программа не может обработать в обычном режиме, .NET создает специальный объект, описывающий эту ошибку. Этот объект и есть **исключение** (Exception).

Это принципиально отличает исключения от **ошибок компиляции**. Ошибку компиляции (например, пропущенную точку с запятой) обнаруживает компилятор, и вы не можете даже запустить программу. Исключение происходит уже _во время работы_ запущенной программы.

Если исключение не обработать, выполнение программы аварийно завершится.

```csharp
// Этот код вызовет исключение, так как
// текст "abc" нельзя превратить в число.
int number = int.Parse("abc");

// Эта строка никогда не выполнится
Console.WriteLine("Программа завершена.");

// Результат: Аварийное завершение с ошибкой
// System.FormatException: 'Input string was not in a correct format.'
```

Механизм исключений позволяет нам "перехватывать" такие ошибки и решать, что делать дальше: сообщить пользователю, попробовать еще раз или безопасно завершить операцию.

---

## **Глава 2. Механизм `try-catch-finally`**

Для обработки исключений в C# используется специальная конструкция `try-catch-finally`.

- try (попытаться)
    
    В этот блок помещается "опасный" код, который потенциально может вызвать исключение.
    
- catch (поймать)
    
    Этот блок выполняется только в том случае, если в блоке try произошло исключение. Он "ловит" объект исключения, и мы можем выполнить код для обработки ошибки (например, записать лог или показать сообщение пользователю).
    
- finally (в любом случае)
    
    Этот блок выполняется всегда: и если try завершился успешно, и если было поймано исключение. Он нужен для освобождения ресурсов (например, закрытия файла или сетевого соединения), которые должны быть освобождены независимо от успеха операции.

```csharp
public void ReadFile(string path)
{
    StreamReader reader = null;
    try
    {
        // Опасный код: файл может не существовать
        reader = new StreamReader(path);
        string content = reader.ReadToEnd();
        Console.WriteLine(content);
    }
    catch (FileNotFoundException ex)
    {
        // Обработка конкретной ошибки: файл не найден
        Console.WriteLine($"Ошибка: Файл '{path}' не найден.");
    }
    catch (Exception ex)
    {
        // Обработка всех остальных ошибок
        Console.WriteLine($"Произошла неизвестная ошибка: {ex.Message}");
    }
    finally
    {
        // Освобождение ресурсов. Этот код выполнится всегда.
        if (reader != null)
        {
            reader.Close();
            Console.WriteLine("Файл закрыт.");
        }
    }
}
```

> **Примечание:** Конструкция `using` (которую мы видели в статье про память и `IDisposable`) — это "синтаксический сахар" для `try-finally`. Компилятор автоматически превращает `using (var reader = new StreamReader(path))` в `try-finally` с вызовом `reader.Dispose()` в блоке `finally`.

---

## **Глава 3. Иерархия исключений и фильтрация**

В .NET все исключения — это классы, которые наследуются от базового класса `System.Exception`. Этот класс содержит основную информацию об ошибке:

- `Message`: Текстовое описание ошибки.
    
- `StackTrace`: "След" вызовов методов, который привел к ошибке.
    
- `InnerException`: Ссылка на предыдущее исключение, если текущее было вызвано им.

Существует множество встроенных типов исключений для разных ситуаций:

- `NullReferenceException`: Попытка использовать объект, который равен `null`.
    
- `ArgumentNullException`: В метод передали `null` в качестве аргумента, который им быть не C.
    
- `FileNotFoundException`: Попытка обратиться к файлу, который не существует.
    
- `InvalidOperationException`: Метод был вызван, когда объект находится в неподходящем состоянии.

Поскольку это классы, мы можем использовать несколько блоков `catch` для "фильтрации" исключений.

**Важно:** Блоки `catch` должны идти от **более конкретного** (наследника) к **более общему** (родителю).

```csharp
try
{
    // ... какой-то код ...
}
catch (FileNotFoundException ex)
{
    // 1. Сначала ловим самую конкретную ошибку
    Console.WriteLine("Файл не найден.");
}
catch (IOException ex)
{
    // 2. Затем более общую ошибку ввода-вывода
    Console.WriteLine("Ошибка чтения файла.");
}
catch (Exception ex)
{
    // 3. В конце ловим все остальные ошибки
    Console.WriteLine("Глобальная ошибка.");
}
```

Если бы `catch (Exception ex)` стоял первым, он бы перехватывал _все_ ошибки, и до `catch (FileNotFoundException ex)`выполнение бы никогда не дошло.

---

## **Глава 4. Создание собственных исключений**

Иногда встроенных типов исключений недостаточно, чтобы описать специфическую ошибку _вашей_ бизнес-логики (например, "Недостаточно средств на счете" в банковском приложении).

В этом случае мы можем создавать собственные классы исключений. Практика — наследовать их от `ApplicationException` (или просто `Exception`).

```csharp
// 1. Создаем свой класс исключения
public class InsufficientFundsException : Exception
{
    public decimal Amount { get; }

    public InsufficientFundsException(string message, decimal amount)
        : base(message)
    {
        Amount = amount;
    }
    
    // Хорошей практикой является добавление всех стандартных конструкторов
    public InsufficientFundsException() { }
    public InsufficientFundsException(string message) : base(message) { }
    public InsufficientFundsException(string message, Exception inner) : base(message, inner) { }
}

// 2. Используем его в логике
public class BankAccount
{
    private decimal _balance = 100;

    public void Withdraw(decimal amount)
    {
        if (amount > _balance)
        {
            // 3. Выбрасываем наше исключение
            throw new InsufficientFundsException("Недостаточно средств", amount);
        }
        _balance -= amount;
    }
}
```

Теперь мы можем целенаправленно ловить `InsufficientFundsException` в коде, который работает с `BankAccount`.

---

## **Глава 5. Ключевое слово `throw`**

Как мы видели в прошлой главе, `throw` используется для "выбрасывания" нового исключения.

`throw new MyCustomException("Сообщение");`

Его также можно использовать внутри блока `catch` для "перебрасывания" пойманного исключения на уровень выше. Это полезно, если вы хотите записать ошибку в лог, но не можете ее обработать на текущем уровне.

**Очень важно:** Существует правильный и неправильный способ сделать это.

```csharp
try
{
    // ... опасный код ...
}
catch (Exception ex)
{
    Log.Error(ex, "Произошла ошибка при операции X");

    // НЕПРАВИЛЬНО: throw ex;
    // Этот способ "срезает" StackTrace.
    // Вы потеряете информацию о том,
    // где изначально возникла ошибка.
    // throw ex; 

    // ПРАВИЛЬНО: throw;
    // Этот способ сохраняет оригинальный StackTrace
    // и просто "пробрасывает" исключение дальше.
    throw;
}
```

---

## **Глава 6. Под капотом: раскрутка стека**

Чтобы понять, как CLR находит нужный `catch`, нужно вспомнить про **стек вызовов** (call stack) (см. статью "Память").

Когда вызывается метод, он помещается на вершину стека. Когда `Метод_А` вызывает `Метод_Б`, `Метод_Б`помещается поверх `Метод_А`.

Что происходит при `throw`:

1. Выполнение `Метода_Б` немедленно останавливается.
    
2. CLR "смотрит" на `Метод_Б`: есть ли здесь `catch`, который может обработать это исключение?
    
3. Если нет, CLR "раскручивает" (unwind) стек: `Метод_Б` удаляется из стека (все его локальные переменные уничтожаются, _но_ `finally` блоки выполняются!).
    
4. CLR "смотрит" на `Метод_А`: есть ли _здесь_ подходящий `catch`?
    
5. Этот процесс (раскрутка стека) продолжается, пока не будет найден подходящий `catch`.

Если CLR раскрутит весь стек до самого начала (до метода `Main`) и не найдет `catch`, программа выдаст "Необработанное исключение" (Unhandled Exception) и аварийно завершит работу.

---

## **Заключение**

**Глава 1.**

- Что такое исключение и чем оно отличается от ошибки компиляции?
    
- Что происходит, если исключение не обработать?

**Глава 2.**

- Для чего нужны блоки `try`, `catch` и `finally`?
    
- В каком случае выполняется блок `finally`?

**Глава 3.**

- От какого базового класса наследуются все исключения?
    
- Почему важен порядок следования блоков `catch`?

**Глава 4.**

- Зачем создавать собственные классы исключений?

**Глава 5.**

- В чем разница между `throw ex;` и просто `throw;` внутри блока `catch`?

**Глава 6.**

- Что такое "раскрутка стека" (stack unwinding) при возникновении исключения?