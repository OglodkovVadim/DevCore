В этой статье мы разберем причины возникновения ООП и его основные принципы.

---

## **Глава 1. Необходимость ООП**

Существует много различных парадигм программирования, и каждая из них подходит под определенный язык (также бывают мультипарадигменные языки) и задачу.

Некоторые примеры парадигм:

#### **Императивная**

Вся логика описывается в виде следующих друг за другом инструкций, последовательно изменяющих состояние программы.

#### **Процедурная**

Основана на императивной, но с возможностью разбиения кода на небольшие самостоятельные участки кода — процедуры. При этом подходе каждая задача разбивается на шаги и для них описываются процедуры.

#### **Функциональная**

В отличие от процедурной парадигмы здесь не хранится состояние программы и не изменяется от шага к шагу. Результаты функций зависят только от входных данных и результатов других функций. Можно сказать, здесь понятие функции совпадает с понятием функции в математике.

#### **Объектно-ориентированная**

Если раньше задачи программирования в основном были низкоуровневые и предполагали хранение и последовательное изменение состояния вычислительной техники, то с развитием технологий изменились и задачи.

Постепенно разрастались вычислительные системы, алгоритмы, стала появляться потребность в цифровизации определенных аспектов нашей жизни. Такого рода задачи требовали серьезного проектирования системы.

Стали появляться языки более высокого уровня абстракции, а все заботы реализации легли на трансляторы (компилятор, интерпретатор и т. д.). Таким образом, человеку стало легче проектировать сложные архитектуры.

Таким образом, возникла необходимость разработки новой, более абстрактной парадигмы программирования.

---

## **Глава 2. Устройство ООП**

Объектно-ориентированное программирование — подход, при котором, что следует из названия, код представляет собой описание объектов и взаимодействия между ними.

Основной единицей этого подхода является **_класс_**. Это пользовательский тип данных, содержащий тематически одинаковые **_поля_** и **_методы_**. В качестве полей класса могут быть как элементарные типы данных (value types), так и объекты других классов (reference types). По задумке эти поля хранят т. н. состояние объекта, а методы класса позволяют выполнять какую-то логику, присущую этому классу.

> Поля, методы, properties (C#) и т. д. — все вместе называется **_члены класса_**.

Таким образом, мы получаем самостоятельную сущность со своим состоянием (поля) и возможностями (методы), тем самым делая код понятным и простым в управлении.

Мы поняли, какие сущности есть в таком подходе и в чем их смысл, теперь надо разобрать правила, по которым эти сущности взаимодействуют. В ООП есть 4 основных принципа (правила): **_абстракция, инкапсуляция, наследование, полиморфизм_**.

---

## **Глава 3. Инкапсуляция**

Представим, что у нас есть машина. Чтобы завести двигатель, водитель нажимает кнопку Start.

Под капотом при этом выполняется несколько шагов (включение ЭБУ, подача искры и т. д.), но водитель не имеет прямого доступа к этим шагам, потому что неправильный порядок их выполнения может сломать двигатель.

В программировании такой подход называется **инкапсуляцией** — это механизм, который позволяет объекту контролировать доступ к своим внутренним данным и методам.

Мы ограничиваем доступ с помощью **модификаторов доступа** (`private`, `public`, `protected`), чтобы не дать пользователю вмешаться во внутреннюю работу класса и нарушить логику.


```csharp
public class Car
{
	private void StartEBU() => Console.WriteLine("Step 1 done!");
	private void StartSpark() => Console.WriteLine("Step 2 done!");
	private void TurnOnPanel() => Console.WriteLine("Step 3 done!");
	private void TurnOnHeadlights() => Console.WriteLine("Step 4 done!");
	private void CheckSystem() => Console.WriteLine("Step 5 done!");
	
	public void Start()
	{
		StartEBU();
		StartSpark(); 
		TurnOnPanel();
		TurnOnHeadlights();
		CheckSystem();
		
		Console.WriteLine("Engine is running successfully!");
	}
}

public class Program
{
	public static void Main(string[] args)
	{
		Car car = new Car();
		car.Start();
	}
}
```

Если бы в классе Car все методы были `public`, то при его использовании мы могли бы, например, в любой момент (например, во время движения) вызвать метод `StartSpark()` и сломать двигатель.

То есть, суть инкапсуляции — это ограничить доступ к тем полям и методам, которые могут нарушить состояние объекта при неверном взаимодействии.

---

## **Глава 4. Наследование**

Представьте, что у нас есть следующий класс `Car`:


```csharp
public class Car
{
	public string Model { get; set; }
	public string Color { get; set; }
	
	public void StartEndine() => 
		Console.WriteLine("Engine is running");
}
```

Теперь нам надо добавить класс `Truck` (типа эвакуатор), который умеет абсолютно то же, что и `Car`, но еще он умеет поднимать машины. Зачем нам переписывать одинаковые поля и методы, которые уже описаны в классе Car? Мы можем просто взять за основу класс `Car` и расширить его, добавив метод `LiftCar().`


```csharp
public class Truck : Car
{
	public void LiftCar() => 
		Console.WriteLine("Car is lifting");
}
```

Таким образом, мы избегаем лишнего дублирования кода. Общий функционал принято выносить в базовый класс, а в классах-наследниках реализуются конкретные различия.

---

## **Глава 5. Полиморфизм**

Полиморфизм (от греч. _poly_ — «много», _morphē_ — «форма») означает, что один метод может иметь множество различных форм.

Существует **_статический_** (его еще называют **_ранним связыванием_**) и **_динамический_** (**_позднее связывание_**) полиморфизм.

#### Статический полиморфизм

Все мы видели на C#, например, в Visual Studio, когда мы пишем название метода из какой-либо библиотеки, он высвечивает подсказку с принимаемыми типами данных в нескольких вариантах и называет их **_перегрузкой_**. Так вот, перегрузка — это и есть пример статического полиморфизма. То есть, становится понятно, какой вариант функции будет использоваться уже на этапе компиляции.

Главные особенности перегрузки методов:

- одинаковое название методов
    
- различие лишь в сигнатуре (возвращаемый тип, аргументы)
    
- минимум одно различие в сигнатуре


```csharp
public class Math
{
	public static int Sum(int a, int b) => a + b;
	public static double Sum(double a, double b) => a + b;
	public static int Sum(int a, int b, int c) => a + b + c;
}
```

#### Динамический полиморфизм

Если при статическом полиморфизме конкретная реализация метода определяется на этапе компиляции по ее сигнатуре, то при динамическом это происходит во время выполнения программы. Когда мы определяем в базовом классе абстрактный или виртуальный метод, то в классах-наследниках его можно переопределить.

> **_Абстрактный метод_** — это метод, который объявляется только в абстрактных классах и не имеет своего определения.
> 
> **_Виртуальный метод_** — это метод, который объявляется в любом классе и имеет свое определение. Это определение, грубо говоря, — значение по умолчанию, которое классы-наследники могут переопределить при желании.

**_Только эти методы можно переопределять в классах-наследниках._**


```csharp
public abstract class Vehicle
{
	public abstract string GetColor();
	public virtual void StartEngine()
	{
		Console.WriteLine("Get inside");
		Console.WriteLine("Put keys in lock");
		Console.WriteLine("Rotate & hold keys")
	}
}

public class Motorcycle : Vehicle
{
	public override string GetColor() => "Red";
	public override void StartEngine()
	{
		Console.WriteLine("Get on a motorcycle");
		Console.WriteLine("Push a kick start lever");
	}
}

public class Truck : Vehicle
{
	public override string GetColor() => "Green";
}

public class SportCar : Vehicle
{
	public override string GetColor() => "Blue";
}
```

---

## **Глава 6. Абстракция**

Принцип абстракции очень похож на принцип инкапсуляции. И тот и другой принцип нужен для удобства работы с классом. В случае инкапсуляции от нас скрывают лишние члены класса, чтобы мы ничего не сломали случайно. А в случае абстракции от нас скрывают детали реализации, которые нам не нужно знать, и дают простой интерфейс для использования.

Допустим, у нас есть несколько классов транспорта, и все они умеют двигаться и останавливаться по-своему.


```csharp
public class Bike
{
	public void Move() => Console.WriteLine("Bike is moving");
	public void Stop() => Console.WriteLine("Bike stopped");
}

public class Car
{
	public void Move() => Console.WriteLine("Car is moving");
	public void Stop() => Console.WriteLine("Car stopped");
}

public class Truck
{
	public void Move() => Console.WriteLine("Truck is moving");
	public void Stop() => Console.WriteLine("Truck stopped");
}
```

Теперь с такими сущностями мы должны создать программу, которая последовательно запускает гонку с каждым транспортом.


```csharp
public class Program
{
	public static void BikeRace(Bike bike)
	{
		bike.Move();
		Thread.Sleep(5000);
		bike.Stop();
	}
	
	public static void CarRace(Car car)
	{
		car.Move();
		Thread.Sleep(5000);
		car.Stop();
	}
	
	public static void TruckRace(Truck truck)
	{
		truck.Move();
		Thread.Sleep(5000);
		truck.Stop();
	}
	
	public static void Main(string[] args)
	{
		Bike bike = new Bike();
		Car car = new Car();
		Truck truck = new Truck();
		
		BikeRace(bike);
		CarRace(car);
		TruckRace(truck);
	}
}
```

Теперь представим, что будет, если у нас добавятся еще 5 классов транспорта, тогда нам надо будет помимо описания этих 5 классов, добавить еще 5 одинаковых функций, которые принимают объекты разных классов.

Теперь посмотрим, что дает нам абстракция:


```csharp
public abstract class Vehicle
{
	public abstract void Move();
	public abstract void Stop();
}

public class Bike : Vehicle
{
	public override void Move() => Console.WriteLine("Bike is moving");
	public override void Stop() => Console.WriteLine("Bike stopped");
}

public class Car : Vehicle
{
	public override void Move() => Console.WriteLine("Car is moving");
	public override void Stop() => Console.WriteLine("Car stopped");
}

public class Truck : Vehicle
{
	public override void Move() => Console.WriteLine("Truck is moving");
	public override void Stop() => Console.WriteLine("Truck stopped");
}

public class Program
{
	public static void Race(Vehicle vehicle)
	{
		vehicle.Move();
		Thread.Sleep(5000);
		vehicle.Stop();
	}
	
	public static void Main(string[] args)
	{
		List<Vehicle> vehicles =
		[
			new Bike(),
			new Car(),
			new Truck()
		]
		
		vehicle.ForEach(Race);
	}
}
```

Теперь мы можем не привязываться к конкретным типам, а работать с ними через абстракцию в виде класса `Vehicle`.

---

## **Глава 7. Интерфейсы**

Помимо абстрактных классов есть еще **_интерфейсы_**. Это тот же самый абстрактный тип данных, чей экземпляр нельзя создать, но методы его могут быть только абстрактными, причем слово `abstract` не указывается.


```csharp
public interface IPrintable
{
	public void print(string message);
}
```

В C# не поддерживается множественное наследование от базовых классов, но можно имплементировать множество интерфейсов. Связано это с тем, что методы в интерфейсах лежат не в **method table** (как у всех обычных классов и базовых классов), а в **interface map**, поиск по которому занимает больше времени, чем по первому.

Также интерфейс не может содержать обычные поля, а только свойства (properties) и методы. То есть интерфейс, грубо говоря, определяет, что класс (который его имплементирует) умеет.

---

## **Глава 8. Композиция**

Композиция — это подход, при котором объекты создаются **_из_** других объектов, а не расширяют их. Например, есть у нас объект двигатель (Engine), у него свои поля и свой функционал. Он как бы является самостоятельным объектом. А есть класс машина (Car), которая содержит в себе поле Engine и использует его функционал, когда нужно.


```csharp
public class Engine
{
	public string Model { get; set; }
	
	public void Start() => Console.WriteLine("Engine is running");
	public void Stop() => Console.WriteLine("Engine stopped");
}

public class Headlights
{
	public string Color { get; set; }
	
	public void TurnOn() => Console.WriteLine("Headlights on");
	public void TurnOff() => Console.WriteLine("Headlights off");
}

public class Car
{
	public Engine engine = new();
	public Headlights headlights = new();
	
	public void Start()
	{
		engine.Start();
		headlights.TurnOn();
		
		Console.WriteLine("Car is running");
	}
}
```

То есть, некий класс может содержать в себе небольшие самостоятельные классы. Таким образом, достигается _слабая связанность_ между классами. Классы могут быть заменены другими классами, реализующими тот же интерфейс, что позволяет легко изменять поведение классов, не затрагивая другие части системы.

---

## **Заключение**

**Глава 1.**

- Зачем нужно ООП?
    
- Какие парадигмы бывают?

**Глава 2.**

- Что является основной единицей ООП?
    
- В чем суть этой парадигмы?

**Глава 3.**

- Для чего нужна инкапсуляция?

**Глава 4.**

- Что такое наследование?

**Глава 5.**

- Какие виды полиморфизма бывают?
    
- В чем отличие раннего связывания от позднего?
    
- Зачем нужен полиморфизм?

**Глава 6.**

- Какую проблему решает принцип абстракции?

**Глава 7.**

- В чем разница абстрактного класса и интерфейса?
    
- Что может определяться в интерфейсе?

**Глава 8.**

- В чем отличие наследования от композиции?
    
- Какие плюсы композиции?